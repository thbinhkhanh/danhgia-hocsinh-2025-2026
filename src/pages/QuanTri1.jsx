// src/pages/QuanTri.jsx
import React, { useState, useEffect, useContext } from 'react';
import {
  Box,
  Typography,
  Card,
  Button,
  Alert,
  Stack,
  LinearProgress,
  Select,
  MenuItem,
  FormControl,
  Divider,
  Grid,
  Checkbox,
  FormControlLabel,
} from '@mui/material';
import UploadFileIcon from '@mui/icons-material/UploadFile';
import CloudUploadIcon from '@mui/icons-material/CloudUpload';
import * as XLSX from 'xlsx';
import { doc, writeBatch, setDoc, getDoc, getDocs, collection } from "firebase/firestore";
import { db } from "../firebase";
import { useNavigate } from "react-router-dom";
import { ConfigContext } from "../context/ConfigContext";
import { StudentContext } from "../context/StudentContext";

export default function QuanTri() {
  const [selectedFile, setSelectedFile] = useState(null);
  const [message, setMessage] = useState('');
  const [success, setSuccess] = useState(false);
  const [loading, setLoading] = useState(false);
  const [progress, setProgress] = useState(0);

  const navigate = useNavigate();
  const { config, setConfig } = useContext(ConfigContext);
  const [selectedWeek, setSelectedWeek] = useState(1);
  const [systemLocked, setSystemLocked] = useState(false);

  const { classData, setClassData } = useContext(StudentContext);
  const [classes, setClasses] = useState([]);
  const [selectedClass, setSelectedClass] = useState("");
  const [subject, setSubject] = useState("Tin h·ªçc");

  // Load config t·ª´ context ho·∫∑c Firestore
  useEffect(() => {
    const initConfig = async () => {
      try {
        const docRef = doc(db, "CONFIG", "config");
        const docSnap = await getDoc(docRef);
        if (docSnap.exists()) {
          const data = docSnap.data();

          // lu√¥n set tu·∫ßn v√† m√¥n
          setSelectedWeek(data.tuan || 1);
          setSystemLocked(data.hethong === false);
          setSubject(data.mon || (data.congnghe ? "C√¥ng ngh·ªá" : "Tin h·ªçc"));

          setConfig(prev => ({
            ...prev,
            tuan: data.tuan || 1,
            hethong: data.hethong ?? false,
            congnghe: data.congnghe ?? false,
            mon: data.mon || (data.congnghe ? "C√¥ng ngh·ªá" : "Tin h·ªçc"),
          }));
        }
      } catch (err) {
        console.error("L·ªói l·∫•y config t·ª´ Firestore:", err);
      }
    };
    initConfig();
  }, [setConfig]);


  // L·∫•y danh s√°ch l·ªõp
  useEffect(() => {
    const init = async () => {
      try {
        let classList = [];
        if (classData && classData.length > 0) {
          classList = classData;
        } else {
          const snapshot = await getDocs(collection(db, "DANHSACH"));
          classList = snapshot.docs.map(doc => doc.id);
          setClassData(classList);
        }
        setClasses(classList);

        const docRef = doc(db, "CONFIG", "config");
        const docSnap = await getDoc(docRef);
        let configData = { tuan: 1, hethong: false, lop: "" };
        if (docSnap.exists()) configData = docSnap.data();

        setConfig(configData);
        setSelectedWeek(configData.tuan || 1);
        setSystemLocked(configData.hethong === false);

        if (configData.lop && classList.includes(configData.lop)) {
          setSelectedClass(configData.lop);
        } else if (classList.length > 0) {
          setSelectedClass(classList[0]);
        }
      } catch (err) {
        console.error("‚ùå L·ªói load config ho·∫∑c l·ªõp:", err);
        setClasses([]);
        setSelectedClass("");
      }
    };
    init();
  }, [setClassData, setConfig]);

  // X·ª≠ l√Ω file Excel
  const handleFileChange = (event) => {
    const file = event.target.files[0];
    if (file && file.name.endsWith('.xlsx')) {
      setSelectedFile(file);
      setMessage('');
      setSuccess(false);
    } else {
      setSelectedFile(null);
      setMessage('‚ùå Vui l√≤ng ch·ªçn ƒë√∫ng ƒë·ªãnh d·∫°ng file Excel (.xlsx)');
      setSuccess(false);
    }
  };

  const handleUpload = async () => {
    if (!selectedFile) {
      setMessage('‚ùó Ch∆∞a ch·ªçn file!');
      setSuccess(false);
      return;
    }

    setLoading(true);
    setMessage('üîÑ ƒêang x·ª≠ l√Ω file...');
    setProgress(0);

    const reader = new FileReader();
    reader.onload = async (e) => {
      try {
        const data = new Uint8Array(e.target.result);
        const workbook = XLSX.read(data, { type: 'array' });
        const sheet = workbook.Sheets[workbook.SheetNames[0]];
        const range = XLSX.utils.decode_range(sheet['!ref']);

        const headerRow = [];
        for (let C = range.s.c; C <= range.e.c; ++C) {
          const cellAddress = XLSX.utils.encode_cell({ r: 2, c: C });
          const cell = sheet[cellAddress];
          headerRow.push((cell?.v || '').toString().trim().toUpperCase());
        }

        const expectedHeaders = ['STT', 'M√É ƒê·ªäNH DANH', 'H·ªå V√Ä T√äN', 'L·ªöP'];
        const isValidHeader = headerRow.length === expectedHeaders.length &&
          expectedHeaders.every((title, index) => headerRow[index] === title);

        if (!isValidHeader) {
          setLoading(false);
          setSuccess(false);
          setMessage('‚ùå Ti√™u ƒë·ªÅ file kh√¥ng h·ª£p l·ªá. H√†ng 3 ph·∫£i l√†: STT, M√É ƒê·ªäNH DANH, H·ªå V√Ä T√äN, L·ªöP.');
          return;
        }

        const jsonData = XLSX.utils.sheet_to_json(sheet, { defval: '', header: 1, range: 3 });
        const formattedData = jsonData.map(row => {
          const obj = {};
          expectedHeaders.forEach((key, i) => { obj[key] = row[i] ?? ''; });
          return obj;
        });

        await processStudentData(formattedData);
      } catch (err) {
        console.error(err);
        setSuccess(false);
        setMessage('‚ùå L·ªói khi x·ª≠ l√Ω file Excel.');
      } finally {
        setLoading(false);
      }
    };
    reader.readAsArrayBuffer(selectedFile);
  };

  const processStudentData = async (jsonData) => {
    const studentCollection = "DANHSACH";
    const groupedByClass = {};
    jsonData.forEach(row => {
      const lop = row['L·ªöP']?.toString().trim().toUpperCase();
      const maDinhDanh = row['M√É ƒê·ªäNH DANH']?.toString().trim();
      if (!lop || !maDinhDanh) return;
      const student = { stt: row['STT'], maDinhDanh, hoVaTen: row['H·ªå V√Ä T√äN'], lop };
      if (!groupedByClass[lop]) groupedByClass[lop] = [];
      groupedByClass[lop].push(student);
    });

    let totalStudents = 0;
    let errorCount = 0;
    const allLopKeys = Object.keys(groupedByClass);
    const BATCH_LIMIT = 500;

    for (let i = 0; i < allLopKeys.length; i++) {
      const lop = allLopKeys[i];
      const students = groupedByClass[lop];
      totalStudents += students.length;
      setProgress(Math.round(((i + 1) / allLopKeys.length) * 100));

      for (let j = 0; j < students.length; j += BATCH_LIMIT) {
        const batch = writeBatch(db);
        const chunk = students.slice(j, j + BATCH_LIMIT);
        const classDocRef = doc(db, studentCollection, lop);
        const dataToMerge = {};
        chunk.forEach(student => {
          dataToMerge[student.maDinhDanh] = { hoVaTen: student.hoVaTen, stt: student.stt, lop: student.lop };
        });
        batch.set(classDocRef, dataToMerge, { merge: true });
        try { await batch.commit(); } catch { errorCount += chunk.length; }
      }
    }

    if (errorCount === 0) {
      setSuccess(true);
      setMessage(`‚úÖ ƒê√£ th√™m th√†nh c√¥ng ${totalStudents} h·ªçc sinh.`);
      setSelectedFile(null);
    } else {
      setSuccess(false);
      setMessage(`‚ö†Ô∏è C√≥ ${errorCount} h·ªçc sinh l·ªói.`);
    }
  };

  const handleWeekChange = async (e) => {
    const newWeek = e.target.value;
    setSelectedWeek(newWeek);

    try {
      const docRef = doc(db, "CONFIG", "config");
      await setDoc(docRef, { tuan: newWeek }, { merge: true });
      setConfig(prev => ({ ...prev, tuan: newWeek }));
    } catch (err) {
      console.error("L·ªói c·∫≠p nh·∫≠t tu·∫ßn:", err);
    }
  };

  const handleClassChange = async (e) => {
    const newClass = e.target.value;
    setSelectedClass(newClass);

    try {
      const docRef = doc(db, "CONFIG", "config");
      await setDoc(docRef, { lop: newClass }, { merge: true });
      setConfig(prev => ({ ...prev, lop: newClass }));
    } catch (err) {
      console.error("L·ªói c·∫≠p nh·∫≠t l·ªõp:", err);
    }
  };

  const handleCongNgheChange = async (e) => {
    const newCongNghe = e.target.checked;
    setIsCongNghe(newCongNghe);

    try {
      const docRef = doc(db, "CONFIG", "config");
      await setDoc(docRef, { congnghe: newCongNghe }, { merge: true });
      setConfig(prev => ({ ...prev, congnghe: newCongNghe }));
    } catch (err) {
      console.error("‚ùå L·ªói c·∫≠p nh·∫≠t C√¥ng ngh·ªá:", err);
    }
  };

  const handleSubjectChange = async (e) => {
    const newSubject = e.target.value;
    const isCongNghe = newSubject === "C√¥ng ngh·ªá";

    setSubject(newSubject);

    try {
      const docRef = doc(db, "CONFIG", "config");

      // üîÑ Ghi c·∫£ mon v√† congnghe l√™n Firestore
      await setDoc(docRef, {
        mon: newSubject,
        congnghe: isCongNghe,
      }, { merge: true });

      // üîÑ C·∫≠p nh·∫≠t context ƒë·∫ßy ƒë·ªß
      setConfig(prev => ({
        ...prev,
        mon: newSubject,
        congnghe: isCongNghe,
      }));
    } catch (err) {
      console.error("‚ùå L·ªói c·∫≠p nh·∫≠t m√¥n h·ªçc:", err);
    }
  };

  return (
  <Box sx={{ minHeight: '100vh', backgroundColor: '#e3f2fd', pt: 3 }}>
    <Card
      elevation={6}
      sx={{
        p: 4,
        borderRadius: 3,
        maxWidth: 300,
        mx: 'auto',
        mt: 3,
        position: 'relative',
      }}
    >
      <Typography
        variant="h5"
        color="primary"
        fontWeight="bold"
        align="center"
        gutterBottom
      >
        ‚öôÔ∏è QU·∫¢N TR·ªä H·ªÜ TH·ªêNG
      </Typography>

      <Divider sx={{ mb: 4 }} />

      <Box sx={{ width: "100%", maxWidth: 400, mx: "auto" }}>
        {/* üì§ Danh s√°ch h·ªçc sinh */}
        <Typography variant="subtitle1" fontWeight="bold" gutterBottom sx={{ mb: 3 }}>
          üì§ Danh s√°ch h·ªçc sinh
        </Typography>

        <Stack spacing={2} sx={{ mb: 5 }}>
          <Button variant="outlined" component="label" startIcon={<UploadFileIcon />}>
            Ch·ªçn file Excel
            <input type="file" hidden accept=".xlsx" onChange={handleFileChange} />
          </Button>

          {selectedFile && (
            <Typography variant="body2">üìÑ File ƒë√£ ch·ªçn: {selectedFile.name}</Typography>
          )}

          <Button
            variant="contained"
            color="success"
            startIcon={<CloudUploadIcon />}
            onClick={handleUpload}
            disabled={loading}
          >
            {loading ? `üîÑ ƒêang t·∫£i... (${progress}%)` : 'T·∫£i danh s√°ch'}
          </Button>

          {loading && <LinearProgress variant="determinate" value={progress} />}

          {message && (
            <Alert severity={success ? 'success' : loading ? 'info' : 'error'}>
              {message}
            </Alert>
          )}
        </Stack>

        {/* ‚öôÔ∏è C√†i ƒë·∫∑t h·ªá th·ªëng */}
        <Typography variant="subtitle1" fontWeight="bold" gutterBottom sx={{ mb: 3 }}>
          ‚öôÔ∏è C√†i ƒë·∫∑t h·ªá th·ªëng
        </Typography>

        <Stack spacing={2}>
          {/* üîº M√¥n h·ªçc ƒë·∫∑t l√™n tr√™n */}
          <FormControl fullWidth size="small">
            <Select value={subject} onChange={handleSubjectChange}>
              <MenuItem value="Tin h·ªçc">Tin h·ªçc</MenuItem>
              <MenuItem value="C√¥ng ngh·ªá">C√¥ng ngh·ªá</MenuItem>
            </Select>
          </FormControl>

          {/* üîΩ L·ªõp v√† tu·∫ßn ƒë·∫∑t xu·ªëng d∆∞·ªõi */}
          <Box sx={{ display: "flex", gap: 2 }}>
            <FormControl size="small" sx={{ flex: 1 }}>
              <Select value={selectedClass} onChange={handleClassChange}>
                {classes.map((cls) => (
                  <MenuItem key={cls} value={cls}>
                    {cls}
                  </MenuItem>
                ))}
              </Select>
            </FormControl>

            <FormControl size="small" sx={{ flex: 1 }}>
              <Select value={selectedWeek} onChange={handleWeekChange}>
                {[...Array(35)].map((_, i) => (
                  <MenuItem key={i + 1} value={i + 1}>
                    Tu·∫ßn {i + 1}
                  </MenuItem>
                ))}
              </Select>
            </FormControl>
          </Box>
        </Stack>
      </Box>
    </Card>
  </Box>
);

}
